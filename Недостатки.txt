Задание в общей сложности выполнил примерна за 18 часов, есть картинки с отчетами (.png)

Решил перед отправкой снова взглянуть на код, с учетом уже имеющихся знаний.
Заметил ряд недоработок и замечаний

1. Класс Ship, имеет избыточную структуру. В добавок к этому в этом классе нарушена инкапсуляция.
То есть данный класс содержит в себе всю информацию о игровом поле, только ради того, чтобы в процессе
создания корабля "createShip", занести координаты корабля в матрицу игрового поля и эти же координаты
записать в матрицу (массив координат палуб) корабля. Матрица на уровне игрового поля, и матрица на уровне
корабля - дублирование получается.

В данном случае уместнее было бы упростить класс Корабля. Игровое поле должно знать о кораблях,
но никак корабли о игровом поле.

2. При попадении в какой-либо корабль (см. класс Controller метод shoot), нет возвможности 
определить в какой корабль я попал сразу. 

В текущей реализации я беру эскадру противника (изначально массив из 10 кораблей, каждый из которых содержит внутри
себя еще массив с координатами) и перебором (сложность O(n^2)) начинаю смотреть все корабли и их координаты
на соответствие координатам выстрела.

Как я знаю, что попал!? Каждая ячейка игрового поля содержит значения от 0 до 3 - это разные состояния.

Логичнее было бы расширить список информации содержащейся в ячейке, сделать не числом, а объектом, который бы содержал
в себе состояние поля и служебную информацию о корабле, например, его имя и координату или номер палубы.

Пример

cell = {
  state: 1            // 1 - в ячейке есть палуба корабля, стейты в констатнах вроде описывал
  ship: 'Ship1',      // имя корабля - ключ в объекте эскадры
  desck: 1            // номер палубы
}

Далее эскадру из массива с кораблями сделать объектом, ключи которого названия кораблей. Тем самым сделав выстрел по ячейке,
мы сразу знаем в какой корабль попали и сможем получить к нему доступ без цикла (сложность будет O(1)).

Или другой для оптимизации. Можно было создавать при расстановке кораблей "обратный индекс" (или плоский объект, 
кто как назовет) полуб кораблей. То есть это был бы объект ключами которого были все координаты с кораблями на игровом поле,
а значениями имя корабля. Тем самым в такой структуре также быстро можно было определить в кого попали

Пример обратного индекса

const coords = {
  "A1": Ship1,
  "A2": Ship1,
  "A3": Ship1,
  ....
  "E4": Ship5,
}

Все эти меры позволили бы выполнять меньше операций, сократили объем кода и повысили читабельность. 
На данный момент логика выстрела очень большая, да и сложно читается.

Вскоре после написания "Морского боя" за пару недель прочитал книгу Адитья Бхаргава "Грокаем алгоритмы",
поэтому еще раз с учетом полученных знаний интересно было взглянуть на код.